package uod.gla.util;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;
import java.util.Random;
import java.util.function.DoubleUnaryOperator;

/**
 * This class is used for generating random integer and double arrays.
 *
 * @author Chi Onyekaba [c.onyekaba@dundee.ac.uk]
 * @version 1.2
 * @since February 22, 2018
 */
public class ArrayGen {

    private static Random rnd = new Random();

    /**
     * Sets the seed of the random number generator used by this class. The
     * sequence of random values generated by this class will remain the same
     * for the same seed value. Calling this method alters the state of the
     * random number generator as if it was newly initialised.
     *
     * @param seed The random number seed.
     */
    public static void setSeed(long seed) {
        rnd.setSeed(seed);
    }

    /**
     * Resets the seed of the random number generator used by this class as if a
     * new random object was created with no seed argument. Calling this method
     * alters the state of the random number generator as if it was newly
     * initialised.
     */
    public static void resetSeed() {
        rnd = new Random();
    }

    /**
     * Generates and returns an integer array of specified length, within the
     * bounds defined by the {@code lowerBound} and {@code upperBound}
     * parameters.
     *
     * @param arrayLength The number of elements in the array
     * @param lowerBound The value of the smallest element in the array
     * @param upperBound The value of the largest element in the array
     * @return An integer array of random integer values.
     * @throws IllegalArgumentException If {@code arrayLength} value is negative
     */
    public static int[] getIntArray(int arrayLength, int lowerBound,
            int upperBound) throws IllegalArgumentException {
        if (arrayLength < 0) {
            throw new IllegalArgumentException("Array length cannot be negative!");
        } else if (arrayLength == 0) {
            return new int[0];
        }
        if (upperBound == lowerBound) {
            int[] array = new int[arrayLength];
            Arrays.fill(array, lowerBound);
            return array;
        } else if (lowerBound > upperBound) { // Reorder bounds if needed
            int temp = lowerBound;
            lowerBound = upperBound;
            upperBound = temp;
        }
        if (upperBound != Integer.MAX_VALUE) {
            ++upperBound;
        }
        return rnd.ints(arrayLength, lowerBound, upperBound).toArray();
    }

    /**
     * Generates and returns an integer array of specified array length.
     *
     * @param arrayLength The number of elements in the array
     * @return An integer array of random integer values.
     * @throws IllegalArgumentException If {@code arrayLength} value is negative
     */
    public static int[] getIntArray(int arrayLength)
            throws IllegalArgumentException {
        if (arrayLength < 0) {
            throw new IllegalArgumentException("Array length cannot be negative!");
        } else if (arrayLength == 0) {
            return new int[0];
        }
        return rnd.ints(arrayLength).toArray();
    }

    /**
     * Generates and returns a double array of specified length, within the
     * bounds defined by the {@code lowerBound} and {@code upperBound}
     * parameters.
     *
     * @param arrayLength The number of elements in the array
     * @param lowerBound The value of the smallest element in the array
     * (inclusive)
     * @param upperBound The value of the largest element in the array
     * (exclusive)
     * @return A double array of random values.
     * @throws IllegalArgumentException If {@code arrayLength} value is negative
     */
    public static double[] getDoubleArray(int arrayLength, double lowerBound,
            double upperBound) throws IllegalArgumentException {
        if (arrayLength < 0) {
            throw new IllegalArgumentException("Array length cannot be negative!");
        } else if (arrayLength == 0) {
            return new double[0];
        }
        if (upperBound == lowerBound) {
            double[] array = new double[arrayLength];
            Arrays.fill(array, lowerBound);
            return array;
        } else if (lowerBound > upperBound) { // Reorder bounds if needed
            double temp = lowerBound;
            lowerBound = upperBound;
            upperBound = temp;
        }
        return rnd.doubles(arrayLength, lowerBound, upperBound).toArray();
    }

    /**
     * Generates and returns a double array of specified length, within the
     * bounds defined by the {@code lowerBound} and {@code upperBound}
     * parameters. If any randomly generated element contains more digits to
     * right of the decimal point, than specified by the {@code scale} argument,
     * the generated element is rounded using the rounding mode specified by the
     * {@code roundingMode} parameter.
     *
     * @param arrayLength The number of elements in the array
     * @param lowerBound The value of the smallest element in the array
     * @param upperBound The value of the largest element in the array
     * @param scale The maximum number of digits to the right of the decimal
     * point. The specified scale is checked to ensure that the greatest of the
     * scale values inferred from the {@code lowerBound}, {@code upperBound} and
     * the {@code scale} argument itself is used, however, in any case, it will
     * not have a value greater than 6.
     * @param roundingMode The rounding mode to apply to any digits to the right
     * of the decimal, beyond the specified scale. All rounding modes are
     * permitted except {@code RoundingMode.UNNECESSARY} in which case, it
     * defaults to {@code RoundingMode.HALF_UP}.
     * @return A double array of random values.
     * @throws IllegalArgumentException If {@code arrayLength} value is negative
     */
    public static double[] getDoubleArray(int arrayLength, double lowerBound,
            double upperBound, int scale, RoundingMode roundingMode)
            throws IllegalArgumentException {
        if (arrayLength < 0) {
            throw new IllegalArgumentException("Array length cannot be negative!");
        } else if (arrayLength == 0) {
            return new double[0];
        }
        if (upperBound == lowerBound) {
            double[] array = new double[arrayLength];
            Arrays.fill(array, lowerBound);
            return array;
        } else if (lowerBound > upperBound) { // Reorder bounds if needed
            double temp = lowerBound;
            lowerBound = upperBound;
            upperBound = temp;
        }
        scale = Integer.max(Integer.max(BigDecimal.valueOf(lowerBound).scale(),
                BigDecimal.valueOf(upperBound).scale()), scale);
        int finalScale = scale > 6 ? 6 : scale;
        RoundingMode finalRM = roundingMode == RoundingMode.UNNECESSARY
                ? RoundingMode.HALF_UP : roundingMode;
        DoubleUnaryOperator op = (double operand) -> {
            return BigDecimal.valueOf(operand)
                    .setScale(finalScale, finalRM).doubleValue();
        };
        return rnd.doubles(arrayLength, lowerBound, upperBound).map(op).toArray();
    }

}
